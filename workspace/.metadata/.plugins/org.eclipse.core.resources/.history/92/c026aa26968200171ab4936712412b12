import java.io.ObjectInputStream.GetField;

/**
 * Binary Search Tree, is a node-based binary tree data structure which has the
 * following properties:
 * 
 * The left subtree of a node contains only nodes with keys less than the node’s
 * key. The right subtree of a node contains only nodes with keys greater than
 * the node’s key. The left and right subtree each must also be a binary search
 * tree. There must be no duplicate nodes.
 * 
 * @author viknagar
 *
 */
public class BinarySearchTree {

	Node root;

	class Node {
		int val;
		Node left;
		Node right;

		Node(int val) {
			this.val = val;
		}
	}

	public static void main(String[] args) {
		BinarySearchTree tree = new BinarySearchTree();

		tree.insert(3);
		tree.insert(2);
		tree.insert(1);
		tree.insert(4);
		tree.insert(5);

		tree.inorder();
		System.out.println("#########");
		tree.preorder();
		System.out.println("#########");
		tree.postOrder();
	}

	/**
	 * In case of binary search trees (BST), Inorder traversal gives nodes in
	 * non-decreasing order. To get nodes of BST in non-increasing order, a
	 * variation of Inorder traversal where Inorder itraversal s reversed, can
	 * be used.
	 */
	void inorder() {
		inorderRec(root);
	}

	/**
	 * Preorder traversal is used to create a copy of the tree. Preorder
	 * traversal is also used to get prefix expression on of an expression tree.
	 * Please see http://en.wikipedia.org/wiki/Polish_notation to know why
	 * prefix expressions are useful.
	 */
	void preorder() {
		preOrderRec(root);
	}

	/**
	 * Postorder traversal is used to delete the tree. Please see the question for deletion of tree for details. Postorder traversal is also useful to get the postfix expression of an expression tree. Please see http://en.wikipedia.org/wiki/Reverse_Polish_notation to for the usage of postfix expression.
	 */
	void postOrder() {
		postOrderRec(root);
	}

	// A utility function to do inorder traversal of BST
	void inorderRec(Node root) {
		if (root != null) {
			inorderRec(root.left);
			System.out.println(root.val);
			inorderRec(root.right);
		}
	}

	void preOrderRec(Node root) {
		if (root != null) {
			System.out.println(root.val);
			inorderRec(root.left);
			inorderRec(root.right);
		}
	}

	void postOrderRec(Node root) {
		if (root != null) {
			inorderRec(root.left);
			inorderRec(root.right);
			System.out.println(root.val);
		}
	}

	public void insert(int val) {
		root = insertIntoBST(root, val);
	}

	public Node insertIntoBST(Node root, int val) {
		if (root == null) {
			root = new Node(val);
			return root;
		}

		if (val < root.val) {
			root.left = insertIntoBST(root.left, val);
		} else if (val > root.val) {
			root.right = insertIntoBST(root.right, val);
		}
		return root;
	}

	public Node getRoot() {
		return root;
	}

}
